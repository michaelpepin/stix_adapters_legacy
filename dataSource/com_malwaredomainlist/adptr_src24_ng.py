
import os
import sys
from datetime import datetime
import pprint

from stix.common.information_source import InformationSource, Identity
from stix.core.stix_package import STIXPackage, STIXHeader
from stix.indicator import Indicator
from stix.utils import set_id_namespace as set_ns_stix

from cybox.common.vocabs import ObjectRelationship
from cybox.core.observable import Observable as CyboxOb
from cybox.objects.hostname_object import Hostname
from cybox.objects.uri_object import URI, AnyURI
from cybox.objects.file_object import File
from cybox.objects.address_object import Address
from cybox.utils import set_id_namespace as set_ns_cybox
from cybox.utils import Namespace

from adapters.lib.conns.conndb import db
#from adapters.lib.utils.mngRmtObjs import get_rmt_file
from adapters.lib.utils.cnvtFiles_ng import cnvt_xml2dict
from adapters.lib.utils.mngMSG_ng import log
from adapters.lib.utils.mngSources_r01 import Source
from adapters.lib.utils.mngMisc_ng import isIPv4, isIPv6

ADPTR_SRC_ID = '72771483-4054-43eb-9dec-11196641c615'
ADPTR_NS_STIX = {'http://hailataxii.com': 'opensource'}
ADPTR_NS_CYBOX = Namespace('http://hailataxii.com', 'opensource')
ADPTR_VER_STIX = '1.1.1'



def main():

    dst = {
        "uri"     : "http://172.16.167.138/taxii-discovery-service",
        "usr_name": "admin",
        "usr_pass": "Mikky123",
        "crt_file": "",
        "crt_pass": ""}

    src_data = Source(id_=ADPTR_SRC_ID)
    src = db('local_file', 'source_list', ADPTR_SRC_ID)
    if src:
        src_data.from_dict(src)
        data = extract(src_data)
        # TODO: Test for very large data size, If large Chunk
        if data:
            print transform(data, False).to_xml()

def extract(src):
    """
        extract (from ETL pattern) pull data from a remote site
    :param src: object - from
    :param new_only:
    :return:
    """
    CONN_RMT = False

    if isinstance(src, object):
        # Make local copy for processing
        local_file = "%s/%s.%s" % (os.getcwd(), src._id, src._file_types[0])

        if CONN_RMT:
            if not get_rmt_file(src._uri, src._src_creds, local_file):
                return False

        if src._file_types[0] == 'rss':
            # preprocess_file(src._file_types[0], local_path)
            return cnvt_xml2dict(local_file, '%s/test.json' % os.getcwd())


def load():
    #TODO: send stix packge to TAXII server
    pass


def transform(data, new_only=True):
    """
        transform - The transforms are source specific.
        Source: http://www.malwaredomainlist.com/hostslist/mdl.xml
        data - must be source xml converted to a dictionary

    :param data:
    :param new_only:
    :return:
    """

    # Input validation
    if not isinstance(data, dict):
        return False

    work = []
    history = db('local_file', 'history', ADPTR_SRC_ID)
    value2key = db('local_file', 'value_to_key', 'values')
    items = data.get('rss', {}).get('channel', {}).get('item')

    if items:
        for item in items:
            guid = item.get('guid', {}).get('#text')

            if guid:
                # Check to see if this item has been process before
                # if not, add to work
                if guid in history:
                    if not new_only:
                        work.append(item)
                else:
                    work.append(item)
                    db('local_file', 'history', ADPTR_SRC_ID,
                       {guid: {'date': str(datetime.now())}})

    if work:
        ### Generate STIXPackage and STIXHeader
        set_ns_stix(ADPTR_NS_STIX)
        set_ns_cybox(ADPTR_NS_CYBOX)
        STIXPackage._version = ADPTR_VER_STIX
        pkg = STIXPackage()

        src_info, value2key = gen_info_src({}, 'www.malwaredomainlist.com', value2key)

        hdr = STIXHeader()
        hdr.title = data.get('rss', {}).get('channel', {}).get('title')
        hdr.description = data.get('rss', {}).get('channel', {}).get('description')
        hdr.information_source = src_info
        pkg.stix_header = hdr

        for item in work:
            key = item.get('guid', {}).get('#text')

            # Decompose data description
            tmp = [x.strip() for x in item.get('description').split(',')]
            decomp = {}
            for x in tmp:
                k, v = x.split(':')
                decomp.update({k.strip(): v.strip()})

            # Generate STIX Indicator
            ind, history = gen_indicator(item, key, history)
            ind.producer = src_info
            ind.short_description = 'MDL RefID: %s | %s' % (key, decomp.get('Description'))

            # Decompose host
            host = decomp.get('Host')
            uri = None
            file_ = None
            if '/' in host:
                host, uri = host.split('/', 1)
                # TODO: parse out file Name

            if host:  # Generate Cybox HostName
                obj = Hostname()
                obj.is_domain_name = True
                obj.naming_system = 'DNS'
                obj.hostname_value = host
                ob, value2key = gen_CyboxOb(obj, host, value2key)
                ob.title = 'HostName: %s' % obj.hostname_value

                ind.add_observable(CyboxOb(idref=ob.id_))
                pkg.add_observable(ob)

            if uri:  # Generate Cybox URI
                obj = URI()
                obj.type_ = URI.TYPE_URL
                url = AnyURI('%s/%s' % (host, uri))
                obj.value = url
                ob, value2key = gen_CyboxOb(obj, url, value2key)
                ob.title = 'URL: %s' % url
                ind.add_observable(CyboxOb(idref=ob.id_))
                pkg.add_observable(ob)

            if file_:
                obj = File()

            ip = decomp.get('IP address')
            if ip:
                obj_ip = Address()
                if isIPv4(ip):
                    obj_ip.category = Address.CAT_IPV4
                elif isIPv6(ip):
                    obj_ip.category = Address.CAT_IPV6
                else:
                    break

                obj_ip.is_source = True
                obj_ip.address_value = ip
                # if obj_host:
                #     obj_ip.add_related(obj_host,
                #                     ObjectRelationship.TERM_RESOLVED_TO,
                #                     inline=False)

                ob = CyboxOb(obj_ip)
                ob.title = 'IP: %s' % ip
                ind.add_observable(CyboxOb(idref=ob.id_))
                pkg.add_observable(ob)

            asn = decomp.get('ASN')
            if asn:
                obj_asn = Address()
                obj_asn.category = Address.CAT_ASN
                obj_asn.address_value = asn
                # if obj_host:
                #     obj_asn.add_related(obj_host,
                #                 ObjectRelationship.TERM_CONNECTED_TO,
                #                 inline=False)
                # if obj_ip:
                #     obj_asn.add_related(obj_ip,
                #                 ObjectRelationship.TERM_CONNECTED_TO,
                #                 inline=False)

                ob = CyboxOb(obj_asn)
                ob.title = 'ASN: %s' % ip
                ind.add_observable(CyboxOb(idref=ob.id_))
                pkg.add_observable(ob)

            pkg.add_indicator(ind)

    db('local_file', 'value_to_key', 'values', value2key)
    db('local_file', 'history', ADPTR_SRC_ID, history)
    return pkg


def get_rmt_file(uri, creds, sFile):
    """
    - Simple URL Retrieval function based on python's urllib

    Keyword arguments:

    Returns:
    """

    import urllib
    try:
        urllib.urlretrieve(uri, sFile)
        return True

    except:
        return False

def gen_CyboxOb(obj, key, _db):

    if _db.get(key):
        ob = CyboxOb(idref=_db[key])
    else:
        ob = CyboxOb()
        _db[key] = ob.id_
        ob = CyboxOb(obj)

    return ob, _db


def gen_info_src(data, key, _db={}):

    obj = InformationSource()
    obj.description = 'Public Aggregator of suspect Domains'
    idn, _db = gen_identity(data, key, _db)
    obj.identity = idn

    return obj, _db


def gen_identity(data, key, _db={}):

    if _db.get(key):
        obj = Identity(id_=_db[key])
    else:
        obj = Identity()
        _db[key] = obj.id_
        obj.name = key

    return obj, _db


def gen_indicator(data, key, _db={}):

    if isinstance(data, dict):

        if _db.get(key, {}).get('ind'):
            ind = Indicator(id_=_db[key]['ind'])
            #ind = Indicator(idref=db[key]['ind'])

        else:
            ind = Indicator()
            _db[key].update({'ind': ind.id_})

            time = data.get('title').split('(')[1][:-1]
            ind.title = data.get('title')
            ind.description = '%s | For more detail go here - %s' % (data.get('description'), data.get('link'))
            if time:
                ind.timestamp = datetime.strptime(time, '%Y/%m/%d_%H:%M')
            #ind.producer = src_info

        return ind, _db



# def preprocess_file(file_type, file_path):
#
#     if file_type == 'rss':
#         trimFile_btwn(file_path,
#               '<?xml version="1.0" encoding="ISO-8859-1" ?>',
#               '</rss>')
#
# def clean_file(file_path, str_begin=None, str_end=None):
#
#     return data

if __name__ == '__main__':
    main()

# EOF
